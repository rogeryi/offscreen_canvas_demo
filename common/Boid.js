// JavaScript Document

Boid = function Boid( maxForce, maxSpeed, edgeBehavior ) {
	this.color_r = 0;
	this.color_g = 0;
	this.color_b = 0;
	this.maxForce = maxForce || 1;
	this.maxForceSQ = this.maxForce*this.maxForce;
	this.maxSpeed = maxSpeed || 10;
	this.maxSpeedSQ = this.maxSpeed*this.maxSpeed;
	this.edgeBehavior = edgeBehavior || Boid.EDGE_NONE;

	this.boundsCentre = new Vector3D();
	this.radius = 10.0;
	this.wanderTheta = 0.0;
	this.wanderPhi = 0.0;
	this.wanderPsi = 0.0;
	this.wanderRadius = 16.0;
	this.wanderDistance = 60.0;
	this.wanderStep = 0.25;
	this.lookAtTarget = true;

	this.reset();

}

Boid.EDGE_BOUNCE = 1;
Boid.EDGE_WRAP = 2;
Boid.EDGE_NONE = 0;
Boid.ZERO = new Vector3D(0, 0, 0);

/**
 * Resets the Boid's position, velocity, acceleration and
 * current steering force to zero
 */

Boid.prototype.reset = function() {
	this.velocity = new Vector3D();
	this.position = new Vector3D();
	this.oldPosition = new Vector3D();
	this.acceleration = new Vector3D();
	this.steeringForce = new Vector3D();
}
/**
 * Generates a random wandering force for the Boid.
 * The results of this method can be controlled by the
 * _wanderDistance, _wanderStep and _wanderRadius parameters
 *
 * @param	multiplier
 *
 * By multiplying the force generated by this behavior,
 * more or less weight can be given to this behavior in
 * comparison to other behaviors being calculated by the
 * Boid. To increase the weighting of this behavior, use
 * a number above 1.0, or to decrease it use a number
 * below 1.0
 */

Boid.prototype.wander = function( multiplier) {
	//multiplier = multiplier || 1;

	this.wanderTheta += -this.wanderStep + Math.random() * this.wanderStep * 2;
	this.wanderPhi += -this.wanderStep + Math.random() * this.wanderStep * 2;
	this.wanderPsi += -this.wanderStep + Math.random() * this.wanderStep * 2;

	if ( Math.random() < 0.5 )
	{
		this.wanderTheta = -this.wanderTheta;
	}

	var pos = this.velocity.clone();

	pos.normalize();
	pos.scaleBy(this.wanderDistance);
	pos.incrementBy(this.position);

	var offset = new Vector3D();

	offset.x = this.wanderRadius * Math.cos(this.wanderTheta);
	offset.y = this.wanderRadius * Math.sin(this.wanderPhi);
	offset.z = this.wanderRadius * Math.cos(this.wanderPsi);

	this.steeringForce = this.steer(pos.add(offset));

	if ( multiplier != 1.0 )
	{
		this.steeringForce.scaleBy(multiplier);
	}

	this.acceleration.incrementBy(this.steeringForce);

}
/**
 * Seeks the Boid towards the specified target
 *
 * @param	target
 *
 * The target for the Boid to seek
 *
 * @param	multiplier
 *
 * By multiplying the force generated by this behavior,
 * more or less weight can be given to this behavior in
 * comparison to other behaviors being calculated by the
 * Boid. To increase the weighting of this behavior, use
 * a number above 1.0, or to decrease it use a number
 * below 1.0
 */

Boid.prototype.seek = function( target, multiplier ) {
	this.steeringForce = this.steer(target);
	if ( multiplier != 1 ) {
		this.steeringForce.scaleBy(multiplier);
	}
	this.acceleration.incrementBy(this.steeringForce);
}

/**
 * Use this method to simulate flocking movement in a
 * group of Boids. Flock will combine the separate,
 * align and cohesion steering behaviors to produce
 * the flocking effect. Adjusting the weighting of each
 * behavior, as well as the distance values for each
 * can produce distinctly different flocking behaviors
 *
 * @param	boids
 *
 * An Array of Boids to consider when calculating the
 * flocking behavior
 *
 * @param	separationWeight
 *
 * The weighting given to the separation behavior
 *
 * @param	alignmentWeight
 *
 * The weighting given to the alignment bahavior
 *
 * @param	cohesionWeight
 *
 * The weighting given to the cohesion bahavior
 *
 * @param	separationDistance
 *
 * The distance which each Boid will attempt to maintain
 * between itself and any other Boid in the flock
 *
 * @param	alignmentDistance
 *
 * If another Boid is within this distance, this Boid will
 * consider the other Boid's heading when adjusting it's own
 *
 * @param	cohesionDistance
 *
 * If another Boid is within this distance, this Boid will
 * consider the other Boid's position when adjusting it's own
 *
 * @param	multiplier
 *
 * By multiplying the force generated by this behavior,
 * more or less weight can be given to this behavior in
 * comparison to other behaviors being calculated by the
 * Boid. To increase the weighting of this behavior, use
 * a number above 1.0, or to decrease it use a number
 * below 1.0
 */

Boid.prototype.flock = function( boids , separationWeight, alignmentWeight, cohesionWeight, separationDistance, alignmentDistance, cohesionDistance ) {
	separationWeight = separationWeight || 0.5;
	alignmentWeight = alignmentWeight || 0.1;
	cohesionWeight = cohesionWeight || 0.2;
	separationDistance = separationDistance || 100;
	alignmentDistance = alignmentDistance || 200;
	cohesionDistance = cohesionDistance || 200;

	this.separate(boids, separationDistance, separationWeight);
	this.align(boids, alignmentDistance, alignmentWeight);
	this.cohesion(boids, cohesionDistance, cohesionWeight);
}

/**
 * Separation will attempt to ensure that a certain distance
 * is maintained between any given Boid and others in the flock
 *
 * @param	boids
 *
 * An Array of Boids to consider when calculating the behavior
 *
 * @param	separationDistance
 *
 * The distance which the Boid will attempt to maintain between
 * itself and any other Boid in the flock
 *
 * @param	multiplier
 *
 * By multiplying the force generated by this behavior,
 * more or less weight can be given to this behavior in
 * comparison to other behaviors being calculated by the
 * Boid. To increase the weighting of this behavior, use
 * a number above 1.0, or to decrease it use a number
 * below 1.0
 */

Boid.prototype.separate = function( boids, separationDistance, multiplier) {
	this.steeringForce = this.getSeparation(boids, separationDistance);

	if ( multiplier != 1.0 ) {
		this.steeringForce.scaleBy(multiplier);
	}

	this.acceleration.incrementBy(this.steeringForce);
}
/**
 * Align will correct the Boids heading in order for it
 * to point in the average direction of the flock
 *
 * @param	boids
 *
 * An Array of Boids to consider when calculating the behavior
 *
 * @param	neighborDistance
 *
 * If another Boid is within this distance, this Boid will
 * consider the other Boid's heading when adjusting it's own
 *
 * @param	multiplier
 *
 * By multiplying the force generated by this behavior,
 * more or less weight can be given to this behavior in
 * comparison to other behaviors being calculated by the
 * Boid. To increase the weighting of this behavior, use
 * a number above 1.0, or to decrease it use a number
 * below 1.0
 */

Boid.prototype.align = function( boids, neighborDistance, multiplier ) {
	this.steeringForce = this.getAlignment(boids, neighborDistance);

	if ( multiplier != 1.0 ) {
		this.steeringForce.scaleBy(multiplier);
	}

	this.acceleration.incrementBy(this.steeringForce);
}

/**
 * Cohesion will attempt to make all Boids in the flock converge
 * on a point which lies at the centre of the flock
 *
 * @param	boids
 *
 * An Array of Boids to consider when calculating the behavior
 *
 * @param	neighborDistance
 *
 * If another Boid is within this distance, this Boid will
 * consider the other Boid's position when adjusting it's own
 *
 * @param	multiplier
 *
 * By multiplying the force generated by this behavior,
 * more or less weight can be given to this behavior in
 * comparison to other behaviors being calculated by the
 * Boid. To increase the weighting of this behavior, use
 * a number above 1.0, or to decrease it use a number
 * below 1.0
 */

Boid.prototype.cohesion = function( boids, neighborDistance, multiplier ) {
	this.steeringForce = this.getCohesion(boids, neighborDistance);

	if ( multiplier != 1.0 ) {
		this.steeringForce.scaleBy(multiplier);
	}

	this.acceleration.incrementBy(this.steeringForce);
}

/**
 * After calling one or more of the Boid's steering methods,
 * call the update method in order to set the Boid's position
 * in relation to the force being applied to it as a result of
 * it's steering behaviors. If the Boid's edgeBehavior property
 * is anything other than EDGE_NONE (no edge behavior) then the
 * Boid's position will be modified accordingly after the
 * steering forces have been applied
 */

Boid.prototype.update = function() {
	this.oldPosition.x = this.position.x;
	this.oldPosition.y = this.position.y;
	this.oldPosition.z = this.position.z;

	this.velocity.incrementBy(this.acceleration);

	if ( this.velocity.lengthSquared() > this.maxSpeedSQ )
	{
		this.velocity.normalize();
		this.velocity.scaleBy(this.maxSpeed);
	}

	this.position.incrementBy(this.velocity);

	this.acceleration.x = 0;
	this.acceleration.y = 0;
	this.acceleration.z = 0;

	if( !this.position.equals(this.oldPosition) ) {
		var distance = Vector3D.distance(this.position, this.boundsCentre);

		if( distance > this.boundsRadius + this.radius ) {

			if( this.edgeBehavior == Boid.EDGE_BOUNCE ){

				this.position.decrementBy(this.boundsCentre);
				this.position.normalize();
				this.position.scaleBy(this.boundsRadius + this.radius);

				this.velocity.scaleBy(-1);
				this.position.incrementBy(this.velocity);
				this.position.incrementBy(this.boundsCentre);

			}else{

				this.position.decrementBy(this.boundsCentre);
				this.position.negate();
				this.position.incrementBy(this.boundsCentre);

			}
		}
	}
}




// private methods

Boid.prototype.steer = function( target, ease, easeDistance) {

	ease = ease || false;
	easeDistance = easeDistance || 100;

	this.steeringForce = target.clone();
	this.steeringForce.decrementBy(this.position);

	this.distance = this.steeringForce.normalize();

	if ( this.distance > 0.00001 ) {
		if ( this.distance < easeDistance && ease ) {
			this.steeringForce.scaleBy(this.maxSpeed * ( this.distance / easeDistance ));
		} else {
			this.steeringForce.scaleBy(this.maxSpeed);
		}

		this.steeringForce.decrementBy(this.velocity);
		if ( this.steeringForce.lengthSquared() > this.maxForceSQ ) {
			this.steeringForce.normalize();
			this.steeringForce.scaleBy(this.maxForce);
		}
	}
	return this.steeringForce;
}

Boid.prototype.getSeparation = function( boids, separation) {
	var force = new Vector3D();
	var difference = new Vector3D();
	var distance;
	var count = 0;
	var boid;

	for (var i = 0; i < boids.length; i++)
	{
		boid = boids[i];

		distance = Vector3D.distance(this.position, boid.position);

		if ( distance > 0 && distance < separation )
		{
			this.position.fastSubtract(boid.position, difference);
			difference.normalize();
			difference.scaleBy(1 / distance);

			force.incrementBy(difference);
			count++;
		}
	}

	if ( count > 0 )
	{
		force.scaleBy(1 / count);
	}

	return force;
}

Boid.prototype.getAlignment = function( boids, neighborDistance ) {
	var force = new Vector3D();
	var distance;
	var count = 0;
	var boid;

	for (var i = 0; i < boids.length; i++)
	{
		boid = boids[i];
		distance = Vector3D.distance(this.position, boid.position);

		if ( distance > 0 && distance < neighborDistance )
		{
			force.incrementBy(boid.velocity);
			count++;
		}
	}

	if ( count > 0 )
	{
		force.scaleBy(1 / count);

		if ( force.lengthSquared() > this.maxForceSQ )
		{
			force.normalize();
			force.scaleBy(this.maxForce);
		}
	}

	return force;
}

Boid.prototype.getCohesion = function( boids, neighborDistance ) {
	var force = new Vector3D();
	var distance;
	var count = 0;
	var boid;

	for (var i = 0; i < boids.length; i++) {
		boid = boids[i];
		distance = Vector3D.distance(this.position, boid.position);

		if ( distance > 0 && distance < neighborDistance ) {
			force.incrementBy(boid.position);
			count++;
		}
	}

	if ( count > 0 ) {
		force.scaleBy(1 / count);
		force = this.steer(force);

		return force;
	}

	return force;
}
